import streamlit as st
import pandas as pd
from datetime import datetime
import re
import io
import hashlib
import requests
from urllib.parse import urlparse
import json

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="üèä‚Äç‚ôÇÔ∏è Gesti√≥n Nadadores C.N.L.P",
    page_icon="üèä‚Äç‚ôÇÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ============== CONFIGURACI√ìN ==============

def hash_password(password):
    """Hashea la contrase√±a para almacenamiento seguro"""
    return hashlib.sha256(password.encode()).hexdigest()

# USUARIOS Y PERMISOS - Inicializaci√≥n
def initialize_users():
    if 'users_data' not in st.session_state:
        st.session_state.users_data = {
            "admin": {
                "password": hash_password("admin123"),
                "role": "admin",
                "name": "Administrador Principal",
                "active": True
            },
            "entrenador": {
                "password": hash_password("entrenador123"),
                "role": "entrenador", 
                "name": "Entrenador Principal",
                "active": True
            },
            "asistente": {
                "password": hash_password("asistente123"),
                "role": "asistente",
                "name": "Asistente",
                "active": True
            }
        }

# TABLA DE CONVERSI√ìN DE TIEMPOS
CONVERSION_DATA = {
    "increments": {
        "Libre": 80, "Espalda": 60, "Braza": 100, "Mariposa": 70, "Estilos": 80
    },
    "multipliers": {
        50: 1, 100: 2, 200: 4, 400: 8, 800: 16, 1500: 30, 3000: 60
    },
    "special": {800: 1280, 1500: 2400}
}

# Lista de pruebas
PRUEBAS = [
    "50m Libre", "100m Libre", "200m Libre", "400m Libre", 
    "800m Libre", "1500m Libre", "3000m Libre",
    "50m Espalda", "100m Espalda", "200m Espalda",
    "50m Braza", "100m Braza", "200m Braza",
    "50m Mariposa", "100m Mariposa", "200m Mariposa",
    "100m Estilos", "200m Estilos"
]

# ============== AUTENTICACI√ìN Y GESTI√ìN DE USUARIOS ==============

def check_authentication():
    """Sistema de autenticaci√≥n"""
    initialize_users()
    
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
    
    if not st.session_state.authenticated:
        show_login()
        return False
    else:
        show_user_info()
        return True

def show_login():
    """Formulario de login"""
    st.markdown("# üèä‚Äç‚ôÇÔ∏è Club Nataci√≥n Las Palmas")
    st.markdown("### üîê Sistema Integral de Gesti√≥n")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        st.markdown("#### Iniciar Sesi√≥n")
        
        username = st.text_input("üë§ Usuario")
        password = st.text_input("üîë Contrase√±a", type="password")
        
        if st.button("üöÄ Entrar", type="primary"):
            users = st.session_state.users_data
            if username in users and users[username].get('active', True):
                hashed_password = hash_password(password)
                if hashed_password == users[username]["password"]:
                    st.session_state.authenticated = True
                    st.session_state.username = username
                    st.session_state.user_role = users[username]["role"]
                    st.session_state.user_name = users[username]["name"]
                    st.success("‚úÖ Acceso correcto")
                    st.rerun()
                else:
                    st.error("‚ùå Contrase√±a incorrecta")
            elif username in users and not users[username].get('active', True):
                st.error("‚ùå Usuario desactivado")
            else:
                st.error("‚ùå Usuario no encontrado")
    
    with st.expander("üë• Usuarios del Sistema"):
        users = st.session_state.users_data
        for username, user_data in users.items():
            if user_data.get('active', True):
                st.markdown(f"""
                **{user_data['name']}** (`{username}`)
                - Rol: {user_data['role'].title()}
                - Estado: {'üü¢ Activo' if user_data.get('active', True) else 'üî¥ Inactivo'}
                """)

def show_user_info():
    """Informaci√≥n del usuario en sidebar"""
    with st.sidebar:
        st.success(f"üë§ **{st.session_state.user_name}**")
        role_icons = {"admin": "üëë", "entrenador": "üèãÔ∏è", "asistente": "üëÄ"}
        icon = role_icons.get(st.session_state.user_role, "üë§")
        st.info(f"{icon} **{st.session_state.user_role.title()}**")
        
        if st.button("üö™ Cerrar Sesi√≥n"):
            for key in ['authenticated', 'username', 'user_role', 'user_name']:
                if key in st.session_state:
                    del st.session_state[key]
            st.rerun()

def has_permission(action):
    """Sistema de permisos"""
    if not st.session_state.get('authenticated', False):
        return False
    
    role = st.session_state.get('user_role', 'asistente')
    
    permissions = {
        'admin': ['view', 'edit', 'delete', 'upload', 'download', 'convert', 'user_management'],
        'entrenador': ['view', 'edit', 'upload', 'download', 'convert'],
        'asistente': ['view']
    }
    
    return action in permissions.get(role, [])

def show_user_management():
    """Panel de gesti√≥n de usuarios (solo admin)"""
    if not has_permission('user_management'):
        st.error("‚ùå Sin permisos para gesti√≥n de usuarios")
        return
    
    st.header("üë• Gesti√≥n de Usuarios")
    
    # Lista de usuarios actuales
    st.subheader("üìã Usuarios Actuales")
    users_df = []
    for username, user_data in st.session_state.users_data.items():
        users_df.append({
            'Usuario': username,
            'Nombre': user_data['name'],
            'Rol': user_data['role'].title(),
            'Estado': 'üü¢ Activo' if user_data.get('active', True) else 'üî¥ Inactivo'
        })
    
    if users_df:
        st.dataframe(pd.DataFrame(users_df), use_container_width=True)
    
    # Gesti√≥n por pesta√±as
    tab1, tab2, tab3 = st.tabs(["üîë Cambiar Contrase√±as", "‚ûï Nuevo Usuario", "‚öôÔ∏è Modificar Usuario"])
    
    with tab1:
        st.markdown("**üîë Cambiar Contrase√±a de Usuario**")
        
        with st.form("change_password"):
            col1, col2 = st.columns(2)
            
            with col1:
                target_user = st.selectbox("Usuario", list(st.session_state.users_data.keys()))
                new_password = st.text_input("Nueva Contrase√±a", type="password")
            
            with col2:
                confirm_password = st.text_input("Confirmar Contrase√±a", type="password")
                st.write("") # Espaciado
                st.write("") # Espaciado
            
            if st.form_submit_button("üîÑ Cambiar Contrase√±a", type="primary"):
                if new_password and new_password == confirm_password:
                    if len(new_password) >= 6:
                        st.session_state.users_data[target_user]["password"] = hash_password(new_password)
                        st.success(f"‚úÖ Contrase√±a cambiada para {target_user}")
                        st.rerun()
                    else:
                        st.error("‚ùå La contrase√±a debe tener al menos 6 caracteres")
                else:
                    st.error("‚ùå Las contrase√±as no coinciden")
    
    with tab2:
        st.markdown("**‚ûï Crear Nuevo Usuario**")
        
        with st.form("new_user"):
            col1, col2 = st.columns(2)
            
            with col1:
                new_username = st.text_input("Nombre de Usuario")
                new_name = st.text_input("Nombre Completo")
                new_role = st.selectbox("Rol", ["admin", "entrenador", "asistente"])
            
            with col2:
                new_pass = st.text_input("Contrase√±a", type="password")
                confirm_new_pass = st.text_input("Confirmar Contrase√±a", type="password")
                new_active = st.checkbox("Usuario Activo", value=True)
            
            if st.form_submit_button("‚ûï Crear Usuario", type="primary"):
                if new_username and new_name and new_pass:
                    if new_username not in st.session_state.users_data:
                        if new_pass == confirm_new_pass and len(new_pass) >= 6:
                            st.session_state.users_data[new_username] = {
                                "password": hash_password(new_pass),
                                "role": new_role,
                                "name": new_name,
                                "active": new_active
                            }
                            st.success(f"‚úÖ Usuario {new_username} creado exitosamente")
                            st.rerun()
                        else:
                            st.error("‚ùå Contrase√±as no coinciden o muy cortas (m√≠n. 6 caracteres)")
                    else:
                        st.error("‚ùå El usuario ya existe")
                else:
                    st.error("‚ùå Todos los campos son obligatorios")
    
    with tab3:
        st.markdown("**‚öôÔ∏è Modificar Usuario Existente**")
        
        with st.form("modify_user"):
            col1, col2 = st.columns(2)
            
            with col1:
                modify_user = st.selectbox("Seleccionar Usuario", list(st.session_state.users_data.keys()))
                if modify_user:
                    current_data = st.session_state.users_data[modify_user]
                    modify_name = st.text_input("Nombre Completo", value=current_data['name'])
                    modify_role = st.selectbox("Rol", ["admin", "entrenador", "asistente"], 
                                             index=["admin", "entrenador", "asistente"].index(current_data['role']))
            
            with col2:
                if modify_user:
                    modify_active = st.checkbox("Usuario Activo", value=current_data.get('active', True))
                    st.warning("‚ö†Ô∏è Cambiar el rol o desactivar un usuario afectar√° sus permisos")
            
            col_update, col_delete = st.columns([3, 1])
            
            with col_update:
                if st.form_submit_button("üíæ Actualizar Usuario", type="primary"):
                    if modify_user and modify_name:
                        st.session_state.users_data[modify_user]["name"] = modify_name
                        st.session_state.users_data[modify_user]["role"] = modify_role
                        st.session_state.users_data[modify_user]["active"] = modify_active
                        st.success(f"‚úÖ Usuario {modify_user} actualizado")
                        st.rerun()
                    else:
                        st.error("‚ùå Nombre es obligatorio")
            
            with col_delete:
                if st.form_submit_button("üóëÔ∏è Eliminar", type="secondary"):
                    if modify_user != "admin":  # Proteger cuenta admin principal
                        if st.session_state.get('confirm_user_delete', '') == modify_user:
                            del st.session_state.users_data[modify_user]
                            st.success(f"‚úÖ Usuario {modify_user} eliminado")
                            st.rerun()
                        else:
                            st.session_state.confirm_user_delete = modify_user
                            st.warning("‚ö†Ô∏è Haz clic otra vez para confirmar eliminaci√≥n")
                    else:
                        st.error("‚ùå No se puede eliminar la cuenta admin principal")

# ============== GESTI√ìN DE DATOS ==============

def load_google_sheets(url):
    """Cargar datos desde Google Sheets"""
    try:
        if 'docs.google.com/spreadsheets' in url:
            doc_id = url.split('/d/')[1].split('/')[0]
            csv_url = f"https://docs.google.com/spreadsheets/d/{doc_id}/export?format=xlsx"
            
            response = requests.get(csv_url)
            if response.status_code == 200:
                return pd.ExcelFile(io.BytesIO(response.content))
            else:
                raise Exception(f"Error al acceder a Google Sheets: {response.status_code}")
        else:
            raise Exception("URL no v√°lida de Google Sheets")
    except Exception as e:
        raise Exception(f"Error al cargar Google Sheets: {str(e)}")

def load_data_source():
    """Gesti√≥n unificada de fuentes de datos"""
    st.header("üìä Fuente de Datos")
    
    source_type = st.radio(
        "Selecciona la fuente de datos:",
        ["üìÅ Archivo Local", "üåê Google Sheets Online"],
        horizontal=True
    )
    
    excel_file = None
    
    if source_type == "üìÅ Archivo Local":
        uploaded_file = st.file_uploader(
            "Selecciona archivo Excel",
            type=['xlsx', 'xls'],
            help="Archivo Excel con m√∫ltiples hojas (temporadas)"
        )
        if uploaded_file:
            excel_file = pd.ExcelFile(uploaded_file)
            
    else:  # Google Sheets
        if has_permission('upload'):
            st.markdown("**üìã Instrucciones para Google Sheets:**")
            st.markdown("1. Abre tu Google Sheets")
            st.markdown("2. Ve a **Archivo ‚Üí Compartir ‚Üí Compartir con otros**")
            st.markdown("3. Cambia a **'Cualquier persona con el enlace puede ver'**")
            st.markdown("4. Copia y pega la URL completa aqu√≠")
            
            sheets_url = st.text_input(
                "üîó URL de Google Sheets",
                placeholder="https://docs.google.com/spreadsheets/d/tu-id-aqui/edit...",
                help="Pega la URL completa de tu Google Sheets"
            )
            
            if sheets_url and st.button("üîÑ Conectar con Google Sheets", type="primary"):
                with st.spinner("Conectando con Google Sheets..."):
                    try:
                        excel_file = load_google_sheets(sheets_url)
                        st.session_state.sheets_url = sheets_url
                        st.success("‚úÖ Conectado exitosamente con Google Sheets")
                    except Exception as e:
                        st.error(f"‚ùå Error: {str(e)}")
                        
            if 'sheets_url' in st.session_state and st.button("üîÑ Actualizar desde Google Sheets"):
                with st.spinner("Actualizando datos..."):
                    try:
                        excel_file = load_google_sheets(st.session_state.sheets_url)
                        st.success("‚úÖ Datos actualizados desde Google Sheets")
                    except Exception as e:
                        st.error(f"‚ùå Error al actualizar: {str(e)}")
        else:
            st.warning("‚ö†Ô∏è Sin permisos para conectar fuentes externas")
    
    return excel_file

# ============== CONVERSOR DE TIEMPOS MASIVO ==============

class TimeConverter:
    """Conversor de tiempos entre piscinas"""
    
    def time_to_centesimas(self, time_str):
        """Convierte tiempo a cent√©simas"""
        try:
            time_str = str(time_str).strip().replace(',', '.')
            if ':' in time_str:
                parts = time_str.split(':')
                if len(parts) == 3:  # hh:mm:ss.cc
                    hours, minutes, seconds = int(parts[0]), int(parts[1]), float(parts[2])
                    return int((hours * 3600 + minutes * 60 + seconds) * 100)
                else:  # mm:ss.cc
                    minutes, seconds = int(parts[0]), float(parts[1])
                    return int((minutes * 60 + seconds) * 100)
            else:  # ss.cc
                return int(float(time_str) * 100)
        except:
            return None
    
    def centesimas_to_time(self, centesimas):
        """Convierte cent√©simas a tiempo"""
        try:
            total_seconds = centesimas / 100
            minutes = int(total_seconds // 60)
            seconds = total_seconds % 60
            return f"{minutes:02d}:{seconds:05.2f}"
        except:
            return None
    
    def get_style_distance(self, prueba):
        """Extrae estilo y distancia de la prueba"""
        try:
            parts = prueba.split(' ')
            distance = int(parts[0].replace('m', ''))
            style = parts[1]
            return style, distance
        except:
            return "Libre", 50
    
    def convert_time(self, time_original, pool_from, pool_to, style, distance):
        """Convierte tiempo entre piscinas"""
        if pool_from == pool_to:
            return time_original
        
        centesimas = self.time_to_centesimas(time_original)
        if centesimas is None:
            return time_original
        
        base_increment = CONVERSION_DATA["increments"].get(style, 80)
        
        if distance in CONVERSION_DATA["special"]:
            total_increment = CONVERSION_DATA["special"][distance]
        else:
            multiplier = CONVERSION_DATA["multipliers"].get(distance, 1)
            total_increment = base_increment * multiplier
        
        if pool_from == "25m" and pool_to == "50m":
            converted_centesimas = centesimas + total_increment
        elif pool_from == "50m" and pool_to == "25m":
            converted_centesimas = centesimas - total_increment
        else:
            return time_original
        
        return self.centesimas_to_time(converted_centesimas) or time_original

def show_mass_conversion():
    """Sistema de conversi√≥n masiva"""
    if not has_permission('convert'):
        st.error("‚ùå Sin permisos para conversi√≥n de tiempos")
        return
    
    if 'df' not in st.session_state:
        st.warning("‚ö†Ô∏è Carga primero una temporada para convertir tiempos")
        return
    
    st.header("üîÑ Conversi√≥n Masiva de Tiempos")
    st.markdown("### Convierte todos los tiempos de todos los nadadores de una vez")
    
    converter = TimeConverter()
    df = st.session_state.df.copy()
    
    # Configuraci√≥n de conversi√≥n
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("‚öôÔ∏è Configuraci√≥n")
        target_pool = st.selectbox(
            "üèä‚Äç‚ôÇÔ∏è Convertir todos los tiempos a:",
            ["50m (Piscina Larga)", "25m (Piscina Corta)"],
            help="Se convertir√°n todos los tiempos que no est√©n ya en esta piscina"
        )
        
        target_pool_type = "50m" if "50m" in target_pool else "25m"
        
        # Detectar qu√© tiempos se pueden convertir
        convertible_times = 0
        total_times = 0
        
        for prueba in PRUEBAS:
            if prueba in df.columns:
                piscina_col = f"{prueba}Piscina"
                for idx, row in df.iterrows():
                    tiempo = row.get(prueba, '')
                    piscina = row.get(piscina_col, '')
                    
                    if pd.notna(tiempo) and str(tiempo).strip():
                        total_times += 1
                        if pd.notna(piscina) and str(piscina).strip():
                            piscina_str = str(piscina).strip()
                            if ("25" in piscina_str and target_pool_type == "50m") or \
                               ("50" in piscina_str and target_pool_type == "25m"):
                                convertible_times += 1
        
        st.info(f"üìä **An√°lisis:**")
        st.info(f"‚Ä¢ Total de tiempos: {total_times}")
        st.info(f"‚Ä¢ Convertibles: {convertible_times}")
        st.info(f"‚Ä¢ Ya en {target_pool_type}: {total_times - convertible_times}")
    
    with col2:
        st.subheader("üìã Vista Previa")
        
        if st.checkbox("üîç Mostrar tiempos que se convertir√°n"):
            preview_data = []
            
            for prueba in PRUEBAS[:5]:  # Solo mostrar las primeras 5 pruebas como ejemplo
                if prueba in df.columns:
                    piscina_col = f"{prueba}Piscina"
                    for idx, row in df.iterrows():
                        tiempo = row.get(prueba, '')
                        piscina = row.get(piscina_col, '')
                        nombre = row.get('Nombre', 'Sin nombre')
                        
                        if pd.notna(tiempo) and str(tiempo).strip() and pd.notna(piscina):
                            piscina_str = str(piscina).strip()
                            if ("25" in piscina_str and target_pool_type == "50m") or \
                               ("50" in piscina_str and target_pool_type == "25m"):
                                style, distance = converter.get_style_distance(prueba)
                                converted_time = converter.convert_time(
                                    str(tiempo), piscina_str, target_pool_type, style, distance
                                )
                                
                                preview_data.append({
                                    'Nadador': nombre,
                                    'Prueba': prueba,
                                    'Tiempo Original': f"{tiempo} ({piscina_str})",
                                    'Tiempo Convertido': f"{converted_time} ({target_pool_type})"
                                })
                                
                                if len(preview_data) >= 10:  # Limitar vista previa
                                    break
                    if len(preview_data) >= 10:
                        break
            
            if preview_data:
                st.dataframe(pd.DataFrame(preview_data), use_container_width=True)
                if len(preview_data) >= 10:
                    st.info("... y m√°s (mostrando solo los primeros 10)")
            else:
                st.info("No hay tiempos para convertir")
    
    # Bot√≥n de conversi√≥n
    st.markdown("---")
    
    if convertible_times > 0:
        col_convert, col_info = st.columns([2, 1])
        
        with col_convert:
            if st.button(f"üîÑ Convertir {convertible_times} tiempos a {target_pool_type}", 
                        type="primary", use_container_width=True):
                
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                converted_count = 0
                total_to_convert = convertible_times
                
                # Crear DataFrame convertido
                df_converted = df.copy()
                
                for i, prueba in enumerate(PRUEBAS):
                    if prueba in df_converted.columns:
                        piscina_col = f"{prueba}Piscina"
                        
                        for idx, row in df_converted.iterrows():
                            tiempo = row.get(prueba, '')
                            piscina = row.get(piscina_col, '')
                            
                            if pd.notna(tiempo) and str(tiempo).strip() and pd.notna(piscina):
                                piscina_str = str(piscina).strip()
                                
                                # Determinar si necesita conversi√≥n
                                needs_conversion = False
                                if ("25" in piscina_str and target_pool_type == "50m") or \
                                   ("50" in piscina_str and target_pool_type == "25m"):
                                    needs_conversion = True
                                
                                if needs_conversion:
                                    style, distance = converter.get_style_distance(prueba)
                                    converted_time = converter.convert_time(
                                        str(tiempo), piscina_str, target_pool_type, style, distance
                                    )
                                    
                                    # Actualizar datos
                                    df_converted.at[idx, prueba] = converted_time
                                    df_converted.at[idx, piscina_col] = target_pool_type
                                    
                                    converted_count += 1
                                    
                                    # Actualizar progreso
                                    progress = converted_count / total_to_convert
                                    progress_bar.progress(progress)
                                    status_text.text(f"Convirtiendo: {converted_count}/{total_to_convert}")
                
                # Guardar resultado en session state
                st.session_state.df_converted = df_converted
                st.session_state.conversion_info = {
                    'target_pool': target_pool_type,
                    'converted_count': converted_count,
                    'total_times': total_times,
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
                
                progress_bar.progress(1.0)
                status_text.text("‚úÖ Conversi√≥n completada")
                
                st.success(f"üéâ **Conversi√≥n exitosa!**")
                st.success(f"‚úÖ {converted_count} tiempos convertidos a {target_pool_type}")
                st.info("üì• Ahora puedes descargar el Excel con los tiempos convertidos")
        
        with col_info:
            st.info("‚ÑπÔ∏è **Informaci√≥n:**")
            st.markdown("‚Ä¢ La conversi√≥n no modifica los datos originales")
            st.markdown("‚Ä¢ Se crea una nueva versi√≥n con tiempos convertidos")
            st.markdown("‚Ä¢ Puedes descargar el resultado como Excel")
    else:
        st.info(f"‚ÑπÔ∏è No hay tiempos para convertir a {target_pool_type}")
    
    # Secci√≥n de descarga de resultados convertidos
    if 'df_converted' in st.session_state:
        st.markdown("---")
        st.header("üì• Descargar Resultados Convertidos")
        
        info = st.session_state.conversion_info
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.success(f"‚úÖ **Conversi√≥n realizada:** {info['timestamp']}")
            st.info(f"üîÑ **A piscina:** {info['target_pool']}")
            st.info(f"üìä **Tiempos convertidos:** {info['converted_count']}")
            
            # Crear archivo Excel con datos convertidos
            output = io.BytesIO()
            try:
                current_sheet = st.session_state.get('current_sheet', 'Temporada')
                
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    st.session_state.df_converted.to_excel(
                        writer, 
                        index=False, 
                        sheet_name=f"{current_sheet}_Convertido_{info['target_pool']}"
                    )
                
                output.seek(0)
                
                filename = f"nadadores_convertidos_{info['target_pool']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
                
                st.download_button(
                    label=f"üì• Descargar Excel Convertido a {info['target_pool']}",
                    data=output.getvalue(),
                    file_name=filename,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    type="primary",
                    use_container_width=True
                )
                
            except Exception as e:
                st.error(f"‚ùå Error al crear archivo: {str(e)}")
        
        with col2:
            # Comparaci√≥n r√°pida
            st.subheader("üìä Comparaci√≥n")
            original_times = len([t for prueba in PRUEBAS if prueba in st.session_state.df.columns 
                                for t in st.session_state.df[prueba] if pd.notna(t) and str(t).strip()])
            converted_times = len([t for prueba in PRUEBAS if prueba in st.session_state.df_converted.columns 
                                 for t in st.session_state.df_converted[prueba] if pd.notna(t) and str(t).strip()])
            
            st.metric("Tiempos Originales", original_times)
            st.metric("Tiempos Convertidos", converted_times)
            st.metric("Diferencia", converted_times - original_times)

# ============== VALIDADORES ==============

def validate_time_format(time_str):
    """Valida formato de tiempo"""
    if not time_str or not time_str.strip():
        return True, ""
    
    patterns = [
        r'^\d{1,2}:\d{2}\.\d{2}$',  # mm:ss.cc
        r'^\d{1,2}:\d{2},\d{2}$',   # mm:ss,cc
        r'^\d{1,3}\.\d{2}$',        # ss.cc
        r'^\d{1,2}:\d{2}$',         # mm:ss
    ]
    
    time_str = time_str.strip()
    for pattern in patterns:
        if re.match(pattern, time_str):
            return True, "‚úì"
    
    return False, "‚úó"

def normalize_time(time_str):
    """Normaliza formato de tiempo"""
    if not time_str or not time_str.strip():
        return ""
    
    time_str = time_str.strip().replace(',', '.')
    
    try:
        if re.match(r'^\d{1,3}\.\d{2}$', time_str):
            seconds = float(time_str)
            minutes = int(seconds // 60)
            remaining_seconds = seconds % 60
            return f"{minutes:02d}:{remaining_seconds:05.2f}"
        
        elif re.match(r'^\d{1,2}:\d{2}$', time_str):
            return time_str + ".00"
        
        elif re.match(r'^\d{1,2}:\d{2}\.\d{2}$', time_str):
            return time_str
        
        return time_str
    except:
        return time_str

# ============== APLICACI√ìN PRINCIPAL ==============

def main():
    initialize_users()
    
    # Verificar autenticaci√≥n
    if not check_authentication():
        return
    
    # Inicializar conversor
    converter = TimeConverter()
    
    # T√≠tulo
    st.title("üèä‚Äç‚ôÇÔ∏è Club Nataci√≥n Las Palmas")
    st.markdown("### üèÜ Sistema Integral de Gesti√≥n de Temporadas")
    
    # Navegaci√≥n principal por pesta√±as
    if has_permission('user_management'):
        tabs = st.tabs(["üèä‚Äç‚ôÇÔ∏è Gesti√≥n Nadadores", "üîÑ Conversi√≥n Masiva", "üë• Gesti√≥n Usuarios"])
    else:
        tabs = st.tabs(["üèä‚Äç‚ôÇÔ∏è Gesti√≥n Nadadores", "üîÑ Conversi√≥n Masiva"])
    
    # Pesta√±a 1: Gesti√≥n de Nadadores
    with tabs[0]:
        # Sidebar - Gesti√≥n de datos
        with st.sidebar:
            excel_file = load_data_source()
            
            # Selector de temporada
            if excel_file is not None:
                st.markdown("---")
                st.header("üìÖ Seleccionar Temporada")
                
                sheet_names = excel_file.sheet_names
                st.write(f"**Temporadas disponibles:** {len(sheet_names)}")
                
                selected_sheet = st.selectbox(
                    "üèÜ Temporada:",
                    sheet_names,
                    help="Cada hoja representa una temporada diferente"
                )
                
                if st.button("üìÇ Cargar Temporada", type="primary"):
                    try:
                        df = pd.read_excel(excel_file, sheet_name=selected_sheet)
                        st.session_state.df = df
                        st.session_state.current_sheet = selected_sheet
                        st.success(f"‚úÖ Temporada '{selected_sheet}' cargada")
                        st.success(f"üìä {len(df)} nadadores encontrados")
                    except Exception as e:
                        st.error(f"‚ùå Error: {str(e)}")
        
        # Verificar datos cargados
        if 'df' not in st.session_state:
            st.info("üëà **Conecta tu fuente de datos y selecciona una temporada**")
            
            # Mostrar permisos del usuario
            st.markdown("### üé≠ Tus Permisos en el Sistema:")
            role = st.session_state.get('user_role', 'asistente')
            
            if role == 'admin':
                st.success("üëë **Administrador**: Control total del sistema")
                st.markdown("- ‚úÖ Gesti√≥n completa de nadadores")
                st.markdown("- ‚úÖ Eliminar nadadores")
                st.markdown("- ‚úÖ Conectar Excel online")
                st.markdown("- ‚úÖ Conversor de tiempos masivo")
                st.markdown("- ‚úÖ Gesti√≥n de usuarios y contrase√±as")
            elif role == 'entrenador':
                st.info("üèãÔ∏è **Entrenador**: Gesti√≥n avanzada")
                st.markdown("- ‚úÖ Administrar todos los nadadores")
                st.markdown("- ‚úÖ Editar informaci√≥n y tiempos")
                st.markdown("- ‚úÖ Conversor de tiempos masivo")
                st.markdown("- ‚ùå No puede eliminar nadadores")
                st.markdown("- ‚ùå No puede gestionar usuarios")
            else:
                st.warning("üëÄ **Asistente**: Solo consulta")
                st.markdown("- ‚úÖ Visualizar datos")
                st.markdown("- ‚ùå Sin permisos de edici√≥n")
            
            return
        
        df = st.session_state.df
        current_sheet = st.session_state.get('current_sheet', 'Temporada')
        
        # Mostrar temporada actual
        st.info(f"üìÖ **Temporada Activa:** {current_sheet}")
        
        # ===== TABLA PRINCIPAL DE NADADORES (M√ÅS VISIBLE) =====
        st.header("üìã Lista Completa de Nadadores")
        
        # Filtros en una fila
        col_search, col_sex, col_available = st.columns([2, 1, 1])
        
        with col_search:
            search = st.text_input("üîç Buscar nadador", placeholder="Nombre...")
        
        with col_sex:
            filter_sex = st.selectbox("Sexo", ["Todos", "M", "F"])
        
        with col_available:
            filter_available = st.selectbox("Disponibilidad", ["Todos", "Disponibles", "No disponibles"])
        
        # Aplicar filtros
        df_filtered = df.copy()
        
        if search:
            df_filtered = df_filtered[df_filtered['Nombre'].str.contains(search, case=False, na=False)]
        
        if filter_sex != "Todos":
            df_filtered = df_filtered[df_filtered['Sexo'] == filter_sex]
        
        if filter_available == "Disponibles":
            df_filtered = df_filtered[df_filtered['Disponible'] == True]
        elif filter_available == "No disponibles":
            df_filtered = df_filtered[df_filtered['Disponible'] == False]
        
        # Preparar datos para mostrar con informaci√≥n m√°s visible
        if len(df_filtered) > 0:
            # Crear DataFrame para mostrar con columnas m√°s informativas
            display_df = df_filtered.copy()
            
            # Formatear columnas para mejor visualizaci√≥n
            display_df['Disponible'] = display_df['Disponible'].apply(lambda x: '‚úÖ S√≠' if x else '‚ùå No')
            display_df['Edad'] = display_df.apply(lambda row: datetime.now().year - row.get('A√±oNacimiento', 2000), axis=1)
            
            # Contar tiempos por nadador
            tiempos_count = []
            for idx, row in display_df.iterrows():
                count = 0
                for prueba in PRUEBAS:
                    if prueba in df.columns:
                        tiempo = row.get(prueba, '')
                        if pd.notna(tiempo) and str(tiempo).strip():
                            count += 1
                tiempos_count.append(f"{count} tiempos")
            
            display_df['Tiempos Registrados'] = tiempos_count
            
            # Seleccionar columnas principales para mostrar
            columns_to_show = ['Nombre', 'Sexo', 'A√±oNacimiento', 'Edad', 'Disponible', 'Tiempos Registrados']
            
            # Mostrar tabla principal m√°s grande y clara
            st.dataframe(
                display_df[columns_to_show], 
                use_container_width=True,
                height=400,  # Altura fija para mejor visualizaci√≥n
                column_config={
                    "Nombre": st.column_config.TextColumn("üë§ Nombre", width="large"),
                    "Sexo": st.column_config.TextColumn("‚ö• Sexo", width="small"),
                    "A√±oNacimiento": st.column_config.NumberColumn("üìÖ A√±o Nac.", width="medium"),
                    "Edad": st.column_config.NumberColumn("üéÇ Edad", width="small"),
                    "Disponible": st.column_config.TextColumn("‚úÖ Disponible", width="medium"),
                    "Tiempos Registrados": st.column_config.TextColumn("‚è±Ô∏è Tiempos", width="medium")
                }
            )
            
            # Selector de nadador para editar
            if has_permission('edit'):
                st.markdown("---")
                st.subheader("‚úèÔ∏è Editar Nadador Espec√≠fico")
                
                # Selector m√°s visible
                nadador_names = [f"{row['Nombre']} ({row['Sexo']}, {row['A√±oNacimiento']})" 
                               for idx, row in df_filtered.iterrows()]
                
                if nadador_names:
                    selected_idx = st.selectbox(
                        "Selecciona nadador para editar:",
                        range(len(nadador_names)),
                        format_func=lambda x: nadador_names[x]
                    )
                    
                    # Obtener √≠ndice real
                    real_idx = df_filtered.iloc[selected_idx].name
                    swimmer = df.loc[real_idx]
                    
                    # Formulario de edici√≥n expandido
                    with st.expander(f"‚úèÔ∏è Editando: {swimmer.get('Nombre', 'Sin nombre')}", expanded=True):
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.markdown("**üìù Informaci√≥n Personal:**")
                            
                            with st.form(f"edit_swimmer_{real_idx}"):
                                new_name = st.text_input("Nombre", value=str(swimmer.get('Nombre', '')))
                                new_available = st.checkbox("Disponible", value=bool(swimmer.get('Disponible', False)))
                                new_sex = st.selectbox("Sexo", ['M', 'F'], 
                                                     index=['M', 'F'].index(str(swimmer.get('Sexo', 'M'))) if str(swimmer.get('Sexo', 'M')) in ['M', 'F'] else 0)
                                new_year = st.number_input("A√±o Nacimiento", 
                                                         min_value=1950, max_value=2025, 
                                                         value=int(swimmer.get('A√±oNacimiento', 2000)))
                                
                                col_save, col_delete = st.columns([3, 1])
                                
                                with col_save:
                                    if st.form_submit_button("üíæ Guardar Cambios", type="primary"):
                                        df.loc[real_idx, 'Nombre'] = new_name
                                        df.loc[real_idx, 'Disponible'] = new_available
                                        df.loc[real_idx, 'Sexo'] = new_sex
                                        df.loc[real_idx, 'A√±oNacimiento'] = new_year
                                        df.loc[real_idx, 'Edad'] = datetime.now().year - new_year
                                        
                                        st.session_state.df = df
                                        st.success("‚úÖ Informaci√≥n actualizada")
                                        st.rerun()
                                
                                with col_delete:
                                    if has_permission('delete'):
                                        if st.form_submit_button("üóëÔ∏è Eliminar", type="secondary"):
                                            if st.session_state.get('confirm_delete_swimmer', '') == str(real_idx):
                                                df_updated = df.drop(index=real_idx).reset_index(drop=True)
                                                st.session_state.df = df_updated
                                                st.success("‚úÖ Nadador eliminado")
                                                st.rerun()
                                            else:
                                                st.session_state.confirm_delete_swimmer = str(real_idx)
                                                st.warning("‚ö†Ô∏è Haz clic otra vez para confirmar")
                        
                        with col2:
                            st.markdown("**‚è±Ô∏è Gesti√≥n de Tiempos:**")
                            
                            # Mostrar tiempos existentes
                            swimmer_times = []
                            for prueba in PRUEBAS:
                                tiempo = swimmer.get(prueba, '')
                                if pd.notna(tiempo) and str(tiempo).strip():
                                    piscina = swimmer.get(f"{prueba}Piscina", '')
                                    fecha = swimmer.get(f"{prueba}Fecha", '')
                                    swimmer_times.append({
                                        'Prueba': prueba,
                                        'Tiempo': str(tiempo),
                                        'Piscina': str(piscina),
                                        'Fecha': str(fecha) if pd.notna(fecha) else ''
                                    })
                            
                            if swimmer_times:
                                st.dataframe(pd.DataFrame(swimmer_times), use_container_width=True, height=200)
                            else:
                                st.info("No hay tiempos registrados")
                            
                            # Formulario para a√±adir tiempo
                            with st.form(f"add_time_{real_idx}"):
                                st.markdown("**‚ûï A√±adir Nuevo Tiempo:**")
                                
                                selected_event = st.selectbox("Prueba", PRUEBAS)
                                new_time = st.text_input("Tiempo", placeholder="01:23.45")
                                
                                col_pool, col_date = st.columns(2)
                                with col_pool:
                                    new_pool = st.selectbox("Piscina", ['25m', '50m'])
                                with col_date:
                                    new_date = st.date_input("Fecha", value=datetime.now().date())
                                
                                if st.form_submit_button("üíæ Guardar Tiempo", type="primary"):
                                    if new_time.strip():
                                        valid, _ = validate_time_format(new_time)
                                        if valid:
                                            normalized_time = normalize_time(new_time)
                                            
                                            df.loc[real_idx, selected_event] = normalized_time
                                            df.loc[real_idx, f"{selected_event}Piscina"] = new_pool
                                            df.loc[real_idx, f"{selected_event}Fecha"] = new_date
                                            
                                            st.session_state.df = df
                                            st.success(f"‚úÖ Tiempo guardado: {selected_event}")
                                            st.rerun()
                                        else:
                                            st.error("‚ùå Formato incorrecto")
                                    else:
                                        st.error("‚ùå El tiempo no puede estar vac√≠o")
            
            # Estad√≠sticas de la temporada
            st.markdown("---")
            st.header("üìä Estad√≠sticas de la Temporada")
            
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("üë• Total Nadadores", len(df_filtered))
            
            with col2:
                available_count = len(df_filtered[df_filtered['Disponible'] == True])
                st.metric("‚úÖ Disponibles", available_count)
            
            with col3:
                # Contar total de tiempos
                total_times = 0
                for prueba in PRUEBAS:
                    if prueba in df_filtered.columns:
                        total_times += df_filtered[prueba].notna().sum()
                st.metric("‚è±Ô∏è Tiempos Totales", total_times)
            
            with col4:
                # Promedio de edad
                avg_age = df_filtered.apply(lambda row: datetime.now().year - row.get('A√±oNacimiento', 2000), axis=1).mean()
                st.metric("üéÇ Edad Promedio", f"{avg_age:.1f}")
        
        else:
            st.warning("No se encontraron nadadores con los filtros aplicados")
        
        # Bot√≥n de descarga
        if has_permission('download'):
            st.markdown("---")
            st.header("üì• Descargar Datos")
            
            output = io.BytesIO()
            try:
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, index=False, sheet_name=current_sheet)
                
                output.seek(0)
                
                st.download_button(
                    label=f"üì• Descargar {current_sheet}",
                    data=output.getvalue(),
                    file_name=f"nadadores_{current_sheet}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    type="primary"
                )
                
            except Exception as e:
                st.error(f"Error al crear archivo: {str(e)}")
    
    # Pesta√±a 2: Conversi√≥n Masiva
    with tabs[1]:
        show_mass_conversion()
    
    # Pesta√±a 3: Gesti√≥n de Usuarios (solo admin)
    if has_permission('user_management') and len(tabs) > 2:
        with tabs[2]:
            show_user_management()

if __name__ == "__main__":
    main()